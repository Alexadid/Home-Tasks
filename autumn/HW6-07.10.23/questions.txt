1. Будем кратки:

а) конструктор по умолчанию:

MyClass();


б) копирующий конструктор:

MyClass(const MyClass& other);


в) перемещающий конструктор:

MyClass(MyClass&& other);


г) деструктор:

~MyClass();


д) копирующий оператор присвоения

MyClass& operator=(const MyClass& other);


е) перемещающий оператор присвоения.



2. Пойдём по порядку.

Можно перегружать: арифметические операторы (+, -, *, /, %), операторы сравнения (==, !=, <, >, <=, >=), присвоения (=, +=, -=), унарные и инкремент/декремент (+, -, ++, --, !), а также '[]', '()' и '->'. Также иные разновидности...

Не следует перегружать: ',' (используется для перечисления выражений в операторе, его перегрузка в лучшем случае будем неочевидна в худшем приведёт к непредсказуемому поведения кода), логические операторы (&&, ||), операторы битового сдвига (<<, >>), '&'.

Нельзя перегружать: '.', '->', '? :' (тернарный оператор), '::'.

Кроме того, существует возможность перегружать операторы и 'new', 'new[]', 'delete' и 'delete[]'. Возможность перегружать эти 4 для меня открытие, поэтому я не стал относить их к предыдущим категориям. Скорее всего в их случае стоит быть просто осторожным.



3. Не уверен, что правильно понял, о каких именно преобразованиях идёт речь, но...

В случае оператора преобразования класса из текущего в другой тип или операторов присвоения следует помнить о неявном преобразовании типов. Такие ситуации не следует допускать, так как это может привести к неопределённому поведению кода.



4. Про классификацию по перемещаемость и идентифицируемости (пишу Lvalue и т.д., т.к. С большой буквы видно лучше).

Lvalue:

Перемещаемость: значения Lvalue - это выражения, которые представляют объекты в памяти, и у них есть определённая ячейка памяти. Обычно они находятся в левой части операции присваивания и могут использоваться для присвоения нового значения.
Идентифицируемость: Lvalue имеют чёткий идентификатор или адрес в памяти. Можно взять адрес Lvalue, и он может сохраняться за пределами текущего выражения.

Xvalue:

Перемещаемость: Xvalues - это выражения, которые идентифицируют объект, из которого можно безопасно переместиться, обычно это результат std::move() или когда срок службы объекта подходит к концу.
Идентифицируемость: Xvalues представляют собой объект, из которого можно переместиться, поэтому они всё ещё имеют чёткую идентификацию в памяти, но их срок службы может заканчиваться.

Prvalue:

Перемещаемость: Prvalues - это "чистые" rvalues. Они являются временными значениями и часто используются как результат выражения или при неявном преобразовании объекта.
Идентифицируемость: Значения Prvalues не имеют прямой идентификации в памяти. Они носят временный характер и часто существуют только на время выражения.

Gvalue:

Перемещаемость: Gvalue - это более общий термин, охватывающий как lvalues, так и Prvalues... То есть обобщение.
Идентифицируемость: Gvalues могут включать в себя как выражения, которые имеют четкую идентичность в памяти (lvalues), так и те, которые являются временными и не имеют постоянной идентичности (Prvalues).

Rvalue:

Перемещаемость: Rvalues - это временные значения, которые часто могут появляться в правой части операций присваивания. Обычно они являются результатом выражений или операций, которые создают временные значения.
Идентифицируемость: Rvalues, как и Prvalues, не имеют прямой идентификации в памяти. Они носят временный характер и часто существуют только на время выражения, что следует из того, что они такое же обобществление, как и Gvalue (разница в том, что Rvalue - Xvalue или Prvalue, а не Lvalue или Xvalue).



5. Про необходимость Rvalue-ссылки.

Без них вся идея перемещения не могла бы существовать в том виде, в котором она собственно существует. Rvalue позволяет избежать необходимости создания копий тяжёлых объектов, перемещая задействованные ресурсы в случае 'передачи прав на ресурсы (память)' (под этим я имею ввиду передачу ресурсов от динамически аллоцированной памятью или файл handle) или экономить ресурсы в случае временных объектов. Кроме того, насколько я знаю, Rvalue-ссылки также имеют значение для обеспечения переадресации в шаблонах функций. Однако тут я далёк от полноценного понимания, поэтому это можно считать заметкой на полях...



6. Про семантику перемещений.

Как отмечалось выше перемещать выгоднее, чем делать их копии. Это вполне очевидно позволяет затрачивать намного меньше памяти за счёт того, что не нужно хранить копию объекта - используется часть памяти, которая была аллоцированна для изначального объекта. Кроме того, по тем же причинам, что описаны выше, это занимает меньше времени. Стоит также упомянуть, что перемещение объектов безопаснее, ведь, как минимум в случае с встроенными типами данных, гарантировано не будет выкинуто исключение. В случае же с копированием исключение может быть выкинуто, если памяти не будет хватать (не совсем уверен, так ли хорошо это соотносится с современным c+).



7. std::move

std::move - это функция, которая выполняет преобразование значения Lvalue в Rvalue-ссылку. Обычно она используется для указания на то, что требуется переместить объект, 'передав право на его ресурсы', а не создавая копию.

Отсюда закономерно следуют случаи, когда явно использовать эту функцию не требуется: передача в функцию (оптимизацией перемещения занимается компилятор), возвращение локальной переменной из функции (и так Rvalue-сслыка, так как время жизни функции закончилось) или в случае, если перед нами уже Rvalue, который мы хотим переместить.



8. А кто выполняет перемещение?

Фактическая работа по перемещению данных выполняется конструктором перемещения или оператором присваивания перемещения класса, который определяет перемещаемый объект. Когда используется std::move для объекта, по сути, компилятору сообщается использовать конструктор перемещения или оператор присваивания перемещения (если они определены, конечно), когда этот объект участвует в присваивании или инициализации. Эти конструкторы перемещения или операторы присваивания перемещения отвечают за 'передачу прав на ресурсы' или копирование данных, в зависимости от конкретной реализации в классе.



9. Про пользовательскую реализацию специальных функций-членов класса.

Если обобщать, то в любой ситуации, когда требуется внедрить специфичную логику в схему работы этих функций-членов. В действительности же могут возникать ситуации, когда иначе реализовать код невозможно. Возможно объект требуется действительно копировать, а не переместить. Возможны ошибки (хотя можно ли назвать их ошибками, скорее не определённое поведение) компилятора, которые будут препятствовать реализации некоторых классов (как на семинаре) - компилятор реализует не ту логику, которую мы ожидаем. Кроме того, если реализована хотя бы одна такая функция, то стоит сделать это и с остальными. В противном случае, компилятор может создать несовместимую логику...



10. Про 'default' и 'delete'.

'default': когда используется это ключевое слово в объявлении функции-члена, компилятору сообщается, что следует сгенерировать реализацию этой функции по умолчанию. Это особенно полезно, когда хочется воспользоваться преимуществами кода, сгенерированного компилятором, но всё ещё есть нужда в настройке некоторых других частей класса. Например, можно использовать его для определения конструктора по умолчанию, конструктора копирования, конструктора перемещения, деструктора или оператора присваивания. К примеру:

class MyClass
{
public:
    MyClass() = default; // конструктор по умолчанию
    MyClass(const MyClass& other) = default; // копирующий конструктор
    // и т.д. ...
};

'delete': это ключевое слово используется для явного удаления специальной функции-члена. Это означает, что компилятору сообщается, что он не должен генерировать соответствующую специальную функцию-член. Это используется для предотвращения автоматической генерации функций, которые не имеют смысла для определённого класса. Например, можно использовать его для предотвращения генерации конструктора копирования или оператора присваивания:

class NonCopyable
{
public:
    NonCopyable() = default; // конструктор по умолчанию
    NonCopyable(const NonCopyable&) = delete; // кдаляем копирующий конструктор
    NonCopyable& operator=(const NonCopyable&) = delete; // удаляем копирующий оператор присвоения
    // И т. д. ...
};
