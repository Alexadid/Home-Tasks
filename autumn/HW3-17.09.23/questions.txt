1.

Прежде всего, каждая функция должна иметь четко определенную и единственную цель. Сохранение функции сосредоточенной на конкретных задачах, делает код более модульным и простым для понимания. Следует выбирать осмысленные и описательные названия для функций опять же для повышения читабельности.

Функции следует разрабатывать так, чтобы они были универсальными и применимыми в различных контекстах, придерживаясь принципа DRY (don't repeat yourself). Это не только уменьшает дублирование кода, но и упрощает обслуживание, поскольку изменения или обновления могут быть внесены в одном месте.

Поддержание единообразного стиля кодирования во функциях повышает читаемость кода и облегчает совместную работу над ними. Следует избегать глобальных переменных, когда это возможно, так как они могут привести к неожиданным зависимостям и усложнить анализ кода. Вместо этого разумно использовать параметры функции для инкапсуляции данных и передачи их по мере необходимости.

Кроме того, не стоит забывать об обеспечении надлежащей проверки вводимых данных. Корректная обработка неожиданных или недопустимых данных может предотвратить ошибки во время выполнения и повысить надежность кода.

Надеюсь, что получилось не слишком сухо...

2.

Встраивание вызовов функций обычно относится к практике вызова одной функции внутри аргументов или тела другой функции. Этот прием, используемый в для создания модульного и повторно используемого кода. Есть несколько различных способов, которыми это можно сделать (вызовы функций внутри аргументов функции, вызовы функций внутри тела функции и т.д.).

3.

Значения по умолчанию присваиваются во время объявления функции и служат запасными значениями, когда вызов не предоставляет аргументов для этих параметров. Эти параметры аргумента по умолчанию обычно располагаются справа в списке параметров, а аргументы, не являющиеся параметрами по умолчанию, - слева.

Например:

void myFunction(int arg1, double arg2 = 3.14, char arg3 = 'a');

В этом объявлении arg2 и arg3 имеют значения по умолчанию и могут быть опущены при вызове myFunction.

Однако важно быть осторожным с nullptr в качестве аргумента по умолчанию (сам на этом попадался). Использование nullptr в качестве аргумента по умолчанию может привести к неоднозначностям, если присутствуют перегруженные функции, поскольку компилятор может быть не в состоянии определить, какую перегрузку вызывать, когда аргумент опущен.

4.

Выбор перегруженной функции для вызова в определяется процессом, называемым "разрешение перегрузки функции". Во время этого процесса компилятор учитывает несколько факторов, чтобы принять своё решение. Эти факторы включают количество и типы аргументов, предоставляемых при вызове функции, а также любые преобразования типов, которые могут потребоваться для сопоставления аргументов с параметрами функции.

Компилятор также проверяет наличие любых двусмысленностей или конфликтов в перегруженном наборе функций. Если он не сможет определить наилучшее совпадение или если имеется несколько одинаково хороших совпадений, это приведет к ошибке компиляции.

5.

В C++ вы можно указать "состояние" в функциях и лямбда-выражениях, используя различные методы, в зависимости от требований и желаемого объёма состояния. К примеру:

a) Статические переменные функционального уровня:

Можно использовать статические переменные внутри функций для поддержания "состояния" при нескольких вызовах. Статические переменные объявляются внутри функции и сохраняют свои значения между вызовами функции.
Пример:

#include <iostream>

int functionWithState()
{
    static int state = 0;
    return state++;
}

int main()
{
    std::cout << functionWithState() << std::endl;  // Выводится: 0
    std::cout << functionWithState() << std::endl;  // Выводится: 1
    return 0;
}

б) Лямбда-выражения с захватами:

Лямбда-выражения позволяют захватывать переменные из их области видимости, передавая состояние лямбда-выражению. Можно использовать захваты для захвата локальных переменных по ссылке или по значению (получилась небольшая тавтология).
Пример:

#include <iostream>

int main()
{
    int counter = 0;
    auto lambdaWithState = [&counter]()
    {
        return counter++;
    };

    std::cout << lambdaWithState() << std::endl;  // Выводится: 0
    std::cout << lambdaWithState() << std::endl;  // Выводится: 1

    return 0;
}

в) Лямбда-выражения с изменяемым состоянием:

Если требуется изменить захваченные переменные внутри лямбда-выражения, можно использовать ключевое слово mutable. Оно позволяет изменять состояние захваченных переменных, не изменяя исходные переменные за пределами лямбда-выражения.
Пример:

#include <iostream>

int main()
{
    int counter = 0;
    auto lambdaWithMutableState = [counter]() mutable
    {
        return counter++;
    };

    std::cout << lambdaWithMutableState() << std::endl;  // Выводится: 0
    std::cout << lambdaWithMutableState() << std::endl;  // Выводится: 0 (изменено захваченное значение, а не исходное)

    return 0;
}

г) Использование функциональных объектов (функторов):

Можно создавать классы (функциональные объекты или функторы) для поддержания состояния при нескольких вызовах функций. Эти классы могут иметь переменные-члены для хранения и обновления состояния.
Пример:

#include <iostream>

class StatefulFunctionObject
{
private:
    int state = 0;

public:
    int operator()()
    {
        return state++;
    }
};

int main()
{
    StatefulFunctionObject functor;
    std::cout << functor() << std::endl;  // Выводится: 0
    std::cout << functor() << std::endl;  // Выводится: 1
    return 0;
}

д) Использование функциональных параметров:

Можно передавать информацию о состоянии в качестве параметров функциям, которые могут быть обновлены и возвращены. Этот подход подходит, когда требуется явно управлять состоянием и иметь больше контроля над ним.
Пример:

#include <iostream>

int functionWithState(int& state)
{
    return state++;
}

int main()
{
    int counter = 0;
    std::cout << functionWithState(counter) << std::endl;  // Выводится: 0
    std::cout << functionWithState(counter) << std::endl;  // Выводится: 1
    return 0;
}

Как-то так...