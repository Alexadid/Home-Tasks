1. Шаблоны и их разновидности

Шаблон позволяет писать универсальный код (семейство функций или классов), способный безопасно работать с различными типами данных.

Пример шаблона функции:

template <typename T>
T myFunction(T a, T b)
{
	// Здесь был бы код для работы с типом данных T
}

И для шаблона:

template <typename T>
class MyClass
{
    // Код...
};

2. Двухэтажная трансляция шаблона

А) Определение шаблона:

Первый этап происходит, когда компилятор впервые в тексте обнаруживает шаблон. Фактически код не генерируется на данном этапе, в свою очередь, происходит проверка корректности синтаксиса, не создавая функции или классы для конкретных типов данных.

Б) Создание экземпляра шаблона:

Второй этап происходит, когда компилятор обнаруживает код, использующий шаблон с определёнными аргументами шаблона (типами или значениями). В этот момент происходит компиляция кода, оптимизация и связывание. Результатом является создание специализированных функций или классов, адаптированных к предоставленным аргументам шаблона.

3. Предпочтения компилятора при перегрузке шаблона функции

При перегрузке шаблона функции компилятор следует следующему набору правил:

А) компилятор предпочитает точное соответствие аргументов шаблона;

Б) если точное совпадение не найдено, компилятор пытается вывести аргументы шаблона на основе предоставленных аргументов функции - он рассматривает неявные преобразования, чтобы найти наилучшее соответствие;

В) если после вычета имеется несколько жизнеспособных совпадений, компилятор предпочитает более специализированные шаблоны, включая частичную специализацию для классов шаблонов;

Г) если существует функция, не являющаяся шаблоном, которая соответствует вызову функции, она предпочтительнее шаблонной функции;

Д) наконец, если существует явно специализированный шаблон, соответствующий вызову функции, он предпочтительнее;

Стоит добавить, что функции с аргументами шаблона по умолчанию могут считаться менее специализированными, что влияет на процесс разрешения перегрузки.

4. Особенности инстанциирования шаблонов классов

Особенность инстанциирования шаблонов классов заключается в том, что создание экземпляра шаблона генерирует фактический код для указанных типов в процессе компиляции (то есть только для используемых методов).

Например, рассмотрим универсальный шаблон класса Pair:

template <typename T>
class Pair
{
private:
	T first, second;
public:
	Pair(T a, T b) : first(a), second(b) {}
	// и т.д. другие члены-функции...
};



Pair<int> intPair(1, 2);
Pair<double> doublePair(3.14, 2.71);
Pair<std::string> stringPair("Hello", "World");

В каждом случае компилятор генерирует определенную версию класса Pair, адаптированную к предоставленному типу.