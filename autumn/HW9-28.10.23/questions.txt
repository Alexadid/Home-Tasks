1. Процесс развертывания стека

Последовательность следующая:
1) выбрасывается исключение;
2) стек вызовов разматывается, вызываются деструкторы локальных объектов
3) выполняется поиск соответствующего 'обработчика' исключений
3.1) если 'обработчик' найден, он выполняется и программа продолжается
3.2) в противном случае программа завершается

2. Недостатки механизма кодов возврата

1) Человеческий фактор

Программист может попросту забыть проверить коды возврата, что приведет к игнорированию потенциальных ошибок. Более того, используемый метод обработки может приводить к сложным системам, при разработки которых часть ошибок может быть "забыта".

2) Ограниченное количество информации

Коды ошибок далеки от информативных, они предоставляют минимум информации и контекста, что приводит к усложнению поиска и последующего устранения ошибки.

3) Использование try-catch-throw приводит к захламлению кода, его читабельность падает, а от этого страдает качество разработки.

Как-то так.

3. Особенности механизма исключений

1) возможность вылавливать самые разнообразные исключения от nullptr, деления на ноль или любого поведения, заданного программистом
2) структура try-catch-throw позволяет достаточно безопасно обрабатывать исключения разного рода (в том числе те, которые трудно предугадать при помощи catch(...) и множественных catch в иерархии), при необходимости перебрасывая исключение на внешний уровень 
3) размывание стека безопасно освобождает ресурсы в случае исключения, вызывая деструктор

4. Исключения в noexcept функциях

Если в теле функции, помеченной как noexcept, возникло исключение, это приводит к вызову функции std::terminate, это приводит к завершению работы программы и безопасному освобождению ресурсов путём вызовов деструкторов.

5. Исключения в списках инициализации конструктора класса возникает исключение, будут вызваны деструкторы для уже созданных элементов, а затем исключение будет распространяться из конструктора. Деструкторы вызываются в порядке, обратном их появлению в списке инициализации. Пример, который возможно проиллюстрирует механизм лучше:

class MyClass
{
public:
    // Конструктор со списком инициализации
    MyClass() try : member1(0), member2(0)
    {
	// Кусок кода, который может вызвать исключение во время инициализации
        if (someCondition)
	{
            throw std::runtime_error("Exception during member initialization");
        }

	// Оставшийся код был бы здесь в реальной ситуации
    }
    catch (const std::exception& error)
    {
	// Код для обработки исключений
        std::cerr << "Exception caught in constructor: " << error.what() << std::endl;
	// К данному моменту выполнения кода уже были вызваны деструкторы членов класса
        // Исключение будет распространяться из конструктора во внешний слой
    }

private:
    int member1;
    int member2;
};
