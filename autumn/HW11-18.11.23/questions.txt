1. Ситуации удобного использования вариативных шаблонов

А) Требуется создать универсальную функцию, которая может принимать переменное количество аргументов. Пример:

template <typename... Args>
void printArgs(Args... args)
{
	((std::cout << args << " "), ...);
	std::cout << std::endl;
}

Б) При реализации структур данных, подобных кортежу, которые могут содержать элементы разных типов.
Можно привести пример:

template <typename... Args>
struct Tuple {};

template <typename Head, typename... Tail>
struct Tuple<Head, Tail...>
{
	Head head;
	Tuple<Tail...> tail;
};

В) Рекурсивный вызов функции с переменным числом аргументов, даже тут есть пример:

template <typename T>
T sum(T value)
{
	return value;
}

template <typename T, typename... Args>
T sum(T first, Args... rest)
{
	return first + sum(rest...);
}

Г) При создании функций-оболочек, которые пересылают свои аргументы другой функции. Пример:

template <typename Func, typename... Args>
decltype(auto) forwardAndCall(Func&& func, Args&&... args)
{
	return std::forward<Func>(func)(std::forward<Args>(args)...);
}


2. Поочерёдная обработка аргументов из пакета функции

А) При помощи рекурсивного вызова, пример:

// Base case for recursion
// Базовый случай рекурсии
void processArg(Arg arg)
{
	// Обрабатываем...
	std::cout << arg << ", ";
}

// Рекурсивный вариативный шаблон
template<typename T, typename... Args>
void processArgs(T arg, Args... args)
{
	// Обрабатываем первый аргумент
    	processArg(arg);

	// Рекурсивно вызываем функцию для оставшихся аргументов
    	processArgs(args...);
}

Б) При помощи выражений свёртки (гарантированно обрабатывает слева направо), пример:

// Вариативный шаблон, использующйи выражение свёртки для обработки аргументов
template<typename... Args>
void processArgs(Args... args)
{
	(std::cout << ... << args) << std::endl;
}


3. Вычисление количества параметров в пакете параметров

Решить эту задачу можно, используя рекурсивный шаблонный подход (в конечном итоге всё, конечно, сводится к использованию sizeof). К примеру:

#include <iostream>

// Основной шаблон с пакетом параметров
template <typename... Ts>
struct ParameterCount
{
	static const size_t value = sizeof...(Ts);
};

int main()
{
    std::cout << "Number of parameters: " << ParameterCount<int, double, char>::value << std::endl;

    return 0;
}

Как-то так...

4. Разновидности выражений свертки и уместность их применения

А) Унарное левое выражение свёртки

Используется, когда требуется применить оператор к элементам в наборе параметров слева с указанным начальным значением. Пример использования: суммирование значений в наборе параметров.

Б) Унарное правое выражение свёртки

Используется, когда требуется применить оператор к элементам в наборе параметров справа с указанным начальным значением. Пример использования: конкатенация строк в обратном порядке.

В) Бинарное выражение свёртки

Используется, когда требуется применить оператор к элементам в наборе параметров с указанным начальным значением. Пример использования: вычисление произведения всех элементов в наборе параметров.


