1. Организация механизма генерации случайных чисел

Библиотека random реализует механизм генерации (псевдо-)случайных чисел с помощью генераторов и распределений. Генераторы - это алгоритмы, которые генерируют необработанные случайные числа, с такими параметрами, как std::mt19937 (Вихрь Мерсера) и std::random_device для недетерминированных чисел. Распределения преобразуют эти необработанные числа в числа, которые следуют определенным статистическим шаблонам, таким как std::uniform_real_distribution<> для действительных равномерно распределенных чисел и std::normal_distribution<> для чисел, следующих нормальному распределению.

2. Концепция итераторов, их недостатки

Сама по себе концепция итераторов обеспечивает единый способ доступа к элементам в контейнере (array, vector, deque и т.д.) без раскрытия внутренней структуры контейнера. Итераторы действуют как мост между алгоритмами и контейнерами, позволяя генерализировать подходы к его написанию.

Тем не менее, работа с итераторами имеет ряд недостатков. Во-первых, они могут создавать сложности и подвержены ошибкам, особенно при неправильном использовании, например, при неспособности учесть недействительность итератора после изменения/удаления контейнера. Во-вторых, необходимость управлять типами итераторов (input, output, random access и т.п.) и обеспечивать эффективность производительности усложняет процесс работы с ними.

3. Отличие random access итераторов от contiguous итераторов

Random access и contiguous итераторы в обеспечивают различные уровни функциональности и доступа к элементам в контейнерах.

Random access итераторы обеспечивают прямой доступ к любому элементу последовательности, поддерживая такие операции, как арифметическое сложение, вычитание и сравнение, обеспечивая навигацию и манипулирование внутри контейнеров, таких как vector, deque и array.

Contiguous итераторы, предлагают все возможности random access итераторов, но с дополнительной гарантией: элементы, по которым они выполняют итерацию, хранятся в непрерывном блоке памяти. Это различие критично для приложений, чувствительных к производительности, и при взаимодействии с системами, требующими непрерывной памяти (такими как некоторые C-API). Контейнеры, такие как std::vector и std::array, предоставляют contiguous итераторы, гарантирующие, что элементы не только доступны за константное время, но и физически находятся в едином блоке памяти.

Основное различие между ними заключается в гарантиях хранения в памяти. В то время как random access итераторы фокусируются на эффективном доступе к элементам, не предполагая какого-либо конкретного расположения памяти, contiguous итераторы обеспечивают смежность элементов, повышая производительность и совместимость с низкоуровневыми операциями, которые полагаются на непрерывное расположение памяти.

4. Вызов std::distance last не достижим из first... Что же будет?!

При использовании std::distance(first, last) если last недоступен из first (это означает, что last не может быть достигнут путем увеличения first), мы получим UB. Это поведение возникает из-за того, что distance ожидает допустимый диапазон, в котором last доступен из first. В ситуациях, когда это предварительное условие нарушается, программа может демонстрировать неочевидное поведение, такое как сбои, неправильные вычисления или бесконечные циклы.

5. Предпочтительность алгоритмов STL

Алгоритмы, предоставляемые стандартной библиотекой, как правило, предпочтительнее пользовательских реализаций по нескольким причинам:

1) эффективность - алгоритмы STL высоко оптимизированы для обеспечения производительности в широком диапазоне вариантов использования и платформ. Достичь такого уровня оптимизации без значительных усилий не представляется возможным за вменяемое время.

2) корректность их работы - алгоритмы были тщательно протестированы и отлажены большим сообществом разработчиков. Их использование снижает риск незначительных ошибок, которые могут возникнуть в пользовательском коде (а они возникают примерно всегда).

2) читабельность - стандартные алгоритмы используют хорошо известные имена и шаблоны, что облегчает понимание кода другими пользователями. Преимущество этого очевидно, говорить о нём дальше смысла не вижу...

3) переносимость - алгоритмы стандартной библиотеки разработаны для работы с различными компиляторами и платформами, что делает код, использующий их, более переносимым.

4) сокращение времени разработки - использование стандартной библиотеки позволяет не изобретать велосипед, ускоряя процесс разработки.