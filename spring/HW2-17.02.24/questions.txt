1. Ситуация применения std::pair и std::tuple

std::pair обычно используется для хранения двух связанных (по смыслу, как минимум) значений, например пары ключ-значение или mesh-meta data, или для возврата двух значений из функции. std::tuple в свою очередь расширяет эту концепцию для хранения произвольного количества элементов, что делает его подходящим для функций, возвращающих несколько значений, или для представления сложных данных без определения пользовательской структуры (таблица с колонками, содержащими значения разных типов - tuple в такой ситуации прекрасно подходит для представления строк).

2. std::array - случаи применения, преимущества и недостатки

// Здесь и далее у всех контейнеров подразумевается преимущество в удобстве их удаления и отсутствию необходимости следить за этим...

std::array следует использовать, когда по тем или иным причинам требуется массив фиксированного размера с преимуществами контейнероподобных функций, таких как итераторы и методы, такие как .size().

Преимущества: производительность (нет динамического выделения памяти), безопасность (по сравнения c С-массивами).

Недостатки: фиксированный размер (очевидно), аллокация в стеке (std::array не подходит для очень больших массивов или когда размер массива может превышать размер самого стека).

3. std::vector - случаи применения, преимущества и недостатки

std::vector следует использовать, когда требуется массив с возможностью динамического изменения его размеров и доступу к элементу по индексу.

Преимущества: элементы хранятся в памяти последовательно (может привести к повышению производительности при работе с памятью особенно по сравнению с std::list или std::deque), возможность динамического аллоцирования памяти.

Недостатки: нееэффективные вставки/удаления в середине или начале (вставки и удаления в позициях, отличных от конца, требуют перемещения всех последующих элементов), потенциальная возможность/опасность аплодировать слишком много памяти, затраты памяти.

4. std::deque - случаи применения, преимущества и недостатки

std::deque следует использовать, когда требуется массив с возможностью динамического изменения размеров и эффективного доступа как к его концу, так и к началу.

Преимущества: те же, что и у вектора, но уже упомянутую возможность доступа как к концу, так и к началу.

Недостатки: затраты памяти (ещё большие, чем у вектора за счёт самой реализации), меньшая эффективность при работе с малыми по размерам данными, большие затраты по времени за счёт самой структуры deque.

5. std::list - случаи применения, преимущества и недостатки

std::list следует использовать, когда требуется массив с возможностями эффективной реорганизации его элементов (вставки, удаления и перемещения), а также если не требуется доступ к элементу по индексу.

Преимущества: вставки и удаления за константное время, динамическое выделение памяти, возможность эффективно перемещать элементы.

Недостатки: затраты памяти, меньшая эффективность использования памяти ввиду непоследовательного хранения элементов в памяти, невозможность доступа к элементу по индексу.

6. std::forward_list - случаи применения, преимущества и недостатки

std::forward_list следует использовать, когда требуется массив с возможностями эффективных вставок и удалений в любой его части. При этом он достаточно экономичен в плане используемой памяти.

Преимущества: использует не так много памяти, как предыдущие контейнеры, позволяет эффективно проводить вставки и удаления, эффективен для алгоритмов, которые используют односвязные списки.

Недостатки: меньшая эффективность использования памяти ввиду непоследовательного хранения элементов в памяти, невозможность доступа к элементу по индексу.

7. std::chrono::system_clock и std::chrono::steady_clock в контексте to_time_t()

Всё дело в том, для чего system_clock и steady_clock используются. system_clock представляет время, которое можно изменять - это часы, которые мы видим, как пользователь, так что метод to_time_t() необходим для работы с временем в разных часовых поясах или при работе с летним/зимним временем. В свою очередь, steady_clock не предназначен для этого, на него никак не влияют часовые пояса. Его основное предназначение - это измерение интервалов времени.

8. Использования system_clock и steady_clock

По сути, в прошлом вопросе я уже ответил на этот, но стоит распросраниться...

Варианты использования system_clock: подходит для задач, требующих взаимодействия с реальным временем, таких как планирование будущих событий (запуск процесса резервного копирования в 2 часа ночи по местному времени), запись временных меток событий (когда сервер перестал отвечать) или любой другой вариант использования, где необходимы фактические дата и время.

Варианты использования steady_clock: подходит для измерения временных интервалов с большой точностью и надёжностью, например сравнительный анализ, вычисления тайм-аута или любой сценарий, в котором необходимо точно измерить прошедшее время между событиями без риска изменения, как в системных часов.



???. Пояснения к задаче 3

Таблица последовательных контейнеров, отсортированных по времени их сортировки:

+-------------------+--------------+
| Name of Container | Sorting time |
+-------------------+--------------+
| Array             |        67 ms |
| Vector            |        68 ms |
| Forward List      |       274 ms |
| Deque             |       329 ms |
| List              |       669 ms |
+-------------------+--------------+

На основании ответов на вопросы 2 - 6 можно сделать несколько предположений о том, почему был получен именно такой результат.

Как array, так и vector хранят свои элементы в непрерывном блоке памяти. Эта характеристика позволяет процессору значительно быстрее обращаться к данным, хранящимся в кэше. Кроме того, std::sort использует алгоритм IntroSort, который предназначен именно для подобных контейнеров. Очень близкое время сортировки для array и vector отражает именно этот факт. Небольшую разницу во времени сортировки можно объяснить незначительным отличиями в том, как данные были записаны в кэше (их положение в нём).

Время сортировки для forward_list выше, чем для array и vector, но значительно ниже, чем для list, возможно, из-за более простого устройства контейнера, которое требует меньшего количества манипуляций с  указателями по сравнению с двусвязным списком.

Что можно сказать о deque? Опуская преимущества deque в виде эффективного доступа к обоим его концам, внутренне deque реализован в виде серии массивов фиксированного размера, что обеспечивает лучшую производительность кэширования, но, как правило, хуже, чем один непрерывный массив. Увеличенное время сортировки для deque отражает эту структуру, поскольку алгоритму сортировки приходится иметь дело с дополнительной сложностью и большим временем доступа к элементам, связанным с их не непрерывным расположением памяти.

Наконец, двусвязный характер list требует большего манипулирования указателями (на предыдущий элемент и на следующий), чем forward_list, что приводит к самому высокому времени сортировки среди протестированных контейнеров.

