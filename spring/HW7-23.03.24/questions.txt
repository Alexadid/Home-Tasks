1. Контекстное переключение задач

Контекстное переключение задач относится к процессу изменения контекста выполнения в параллельном программировании, обычно включающему потоки или задачи. Переключение задач происходит, когда операционная система или среда выполнения приостанавливает выполнение одной задачи для возобновления или запуска другой, что является обычной необходимостью в системах, где несколько задач совместно используют ресурсы процессора. Это переключение включает в себя сохранение контекста текущей задачи и загрузку контекста следующей, процесс, известный как переключение контекста.

2. Мнимый и истинный параллелизм

Мнимый параллелизм (псевдопараллелизм) относится к одному процессорному ядру, выполняющему несколько задач путем быстрого переключения между ними, создавая иллюзию одновременного выполнения. С другой стороны, истинный параллелизм предполагает фактическое одновременное выполнение нескольких задач, что возможно только в системах с несколькими процессорами или многоядерных системах, где каждое ядро может одновременно выполнять разные задачи. Вполне возможно организовать воображаемый параллелизм на одноядерном процессоре, поскольку операционные системы используют многопоточность и планирование процессов для управления несколькими задачами на одном ядре. Однако истинный параллелизм не может быть достигнут на одноядерном процессоре, поскольку ему не хватает нескольких процессорных блоков, необходимых для одновременного выполнения задач.

3. Преимущества и недостатки std::thread. Методы .join() и .detach()

std::thread предоставляет собой стандартизированный кросс-платформенный способ управления потокамих, поддерживающий RAII подход и хорошо интегрированный с алгоритмами STL. Тем не менее, std::thread не предоставляет пул потоков или аналогичный механизм более высокого уровня для эффективного управления несколькими потоками, что ведёт и к другой проблеме - необходимости ручной синхронизации потоков (сюда можно записать не только вопросов управления ресурсами, но и обработку исключений).

В свою очередь, методы .join() и .detach() необходимы для управления потоками: .join() блокирует вызывающий поток до завершения указанного потока, гарантируя правильную обработку зависимостей, в то время как .detach() позволяет потоку выполняться независимо, что полезно для задач, которые не влияют на остальную часть потока. поток работы приложения. Каждый метод требует, чтобы поток был доступен для соединения во время его вызова, иначе возникает runtime error.

4. async, future, promise, packaged_task - зачем?

std::async

Упрощает запуск асинхронных задач. Он запускает функцию в новом потоке и возвращает std::future для последующего получения результата.

std::promise

Предоставляет способ вручную задать будущее значение. Это полезно, когда значение определяется при определенных условиях или в определенное время.

std::packaged_task

Обёртывает вызываемый объект и связывает его с std::future. Это идеально подходит для задач, которые необходимо выполнить позже или в определенном контексте, например, для пула потоков.


Разнообразие этих инструментов удовлетворяет различные потребности программирования - от простого асинхронного выполнения до сложных сценариев, требующих контроля над управлением задачами и контекстом выполнения, что позволяет программистам выбирать наиболее подходящий инструмент, исходя из конкретных требований к производительности, гибкости или простоте использования.

5. Проблемы, возникающие при переписывании алгоритма для поддержки параллельного исполнения

а) Балансировка нагрузки - работа должна быть равномерно распределена между потоками для достижения максимальной эффективности.

б) Ошибки параллелизма - такие проблемы, как условия гонки и взаимоблокировки между потоками, могут возникать, если потоки обращаются к общим ресурсам без надлежащей синхронизации.

в) Нагрузка на потоки - управление слишком большим количеством потоков может привести к проблемам с производительностью из-за повышенной частоты переключений контекста и использования памяти.

г) В конце концов, не каждый алгоритм можно исполнять параллельно (классический способ вычисления чисел Фибоначчи)!