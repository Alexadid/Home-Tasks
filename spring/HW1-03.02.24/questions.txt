1. Преимущества сырых указателей по отношению к умным

А) Сырые указатели позволяют манипулировать памятью напрямую, что может быть выгодно в определенных сценариях, где необходим детальный контроль над памятью, например, при написании ПО для микро контроллеров или подобных маломощных устройств.

Б) В некоторых случаях сырые указатели могут обеспечить лучшую производительность по сравнению с умными указателями из-за их простоты и крайне малого количества задействованных ресурсов. Впрочем, это слабо применимо, если мы говорим о unique_ptr, в отличие от shared_ptr

В) Keep it simple, keep it dumb! Далеко не всегда нас интересует, кто владеет ресурсом. Более того, в некоторых ситуациях это может приводить к проблемам (при передаче определённого типа указателя, например shared_ptr, не получится передать, скажем, scoped_ptr).

2. std::shared_ptr создаётся в динамической памяти. Почему?

Во-первых, хранение блока управления в динамической памяти позволяет совместно использовать его среди нескольких экземпляров std::shared_ptr, которые указывают на один и тот же ресурс. Это позволяет правильно отслеживать количество ссылок во всех экземплярах и гарантирует, что объект будет освобожден только тогда, когда все ссылки будут освобождены. Во-вторых, это гарантирует, что он сохраняется до тех пор, пока существуют активные экземпляры std::shared_ptr, ссылающиеся на объект. Это отделяет время жизни блока управления от времени жизни любого отдельного интеллектуального указателя, позволяя механизму подсчета ссылок корректно функционировать даже в сценариях, включающих создание копии, присвоение и уничтожение объектов std::shared_ptr. В-третьих, хранение блока управления в динамической памяти предотвращает проблемы с фрагментацией объектов, которые могли бы возникнуть, если бы блок управления был частью самого объекта умного указателя. Фрагментация объектов происходит, когда объект производного класса присваивается объекту базового класса, что приводит к потере информации, относящейся к производному классу. Сохраняя блок управления отдельно, экземпляры std::shared_ptr могут корректно управлять объектами производных классов, не сталкиваясь с такими проблемами.

3. Предназначение счётчика слабых ссылок в контрольном блоке std::shared_ptr

Счётчик слабых ссылок в блоке управления std::shared_ptr служит для управления слабыми ссылками на ресурс, которым управляет std::shared_ptr. По сути, когда создаётся std::weak_ptr из std::shared_ptr, он напрямую не влияет на количество ссылок управляемого объекта. Вместо этого он содержит слабую ссылку, позволяя ему наблюдать за управляемым объектом без продления его срока службы. Счетчик слабых ссылок предназначен для отслеживания количества экземпляров std::weak_ptr, которые наблюдают за управляемым объектом. В свою очередь, основная цель std::weak_ptr - разорвать потенциальные циклы ссылок, которые могут возникнуть при использовании std::shared_ptr, что может помешать правильному освобождению объектов из-за циклических зависимостей.

4. Злоупотребление методом get() у умных указателей

Начнём с того, что я назвал бы 3 причины, почему не стоит злоупотреблять get(). Поскольку мне не приходилось им злоупотреблять, не уверен, что список полон.

Во-первых, умные указатели обеспечивают автоматическое управление памятью, освобождая память, которой они управляют, когда они выходят за пределы области видимости. Когда используется get() для получения сырого указателя из умного указателя, а затем памятью управляют вручную, теряются преимущества автоматического управления памятью. Это может привести к утечкам памяти, зависанию указателей или двойному удалению, если не следить за этим. Во-вторых, при получении сырого указателя методом get(), становится сложно отследить владение и правильно управлять временем жизни объекта. В-третьих, если умный указатель выходит за пределы области видимости или сбрасывается, в то время как у нас на руках есть сырой указатель, полученный с помощью get(), сырой указатель становится 'зависшим', с позволения сказать, указателем, указывающим на недоступную память. Доступ к таким указателям или их разыменование может привести к неопределенному поведению, включая сбои или повреждение данных.

5. Невозможность копирования unique_ptr

Казалось бы очевидно, но да! std::unique_ptr представляет исключительное (!) право владение объектом. Это означает, что в любой момент времени только один std::unique_ptr может владеть объектом. Если бы можно было скопировать std::unique_ptr, было бы два указателя, владеющих одним и тем же ресурсом, что нарушает принцип уникального владения и лишает unqiue_ptr какого-либо смысла.